# Введение в Softmax алгоритм

## Недостатки **Epsilon-Greedy**

У алгоритма **Epsilon-Greedy** есть очевидная проблема: он перебирает варианты совершенно наугад, не задумываясь об их достоинствах. 

Например, в одном сценарии (назовем его сценарием A) у вас может быть две руки, одна из которых вознаграждает вас в **10 %** случаев, а другая - в **13 %** случаев. 

В сценарии B эти две руки могут вознаграждать вас в **10 %** случаев и в **99 %** случаев. 

В обоих этих сценариях вероятность того, что алгоритм **Epsilon-Greedy** выберет худшую руку, одинакова (она равна epsilon/2), несмотря на то, что худшая рука в сценарии B в относительном выражении гораздо хуже худшей руки в сценарии A.

Это проблема по нескольким причинам:
- Если разница в наградах между двумя руками невелика, вам придется исследовать их гораздо чаще, чем в 10% случаев, чтобы правильно определить, какой из двух вариантов на самом деле лучше.
- Напротив, если разница велика, вам нужно исследовать гораздо меньше, чем в 10 % случаев, чтобы правильно оценить лучший из двух вариантов. По этой причине, исследуя однозначно худший вариант, вы в конечном итоге потеряете много вознаграждения. 

Когда мы впервые описывали алгоритм **Epsilon-Greedy**, мы говорили, что не будем задавать epsilon = 1.0 именно для того, чтобы не тратить время на плохие варианты, но если разница между двумя руками достаточно велика, мы в итоге тратим время на плохие варианты просто потому, что алгоритм Epsilon-Greedy всегда исследует совершенно случайным образом.

Если сложить эти два момента вместе, становится ясно, что алгоритму **Epsilon-Greedy** не хватает качественного свойства. Нам нужно сделать так, чтобы алгоритм бандита заботился об известных различиях между оценочными значениями рук, когда алгоритм решает, какую руку исследовать. Нам нужно структурированное исследование, а не бессистемное, которое обеспечивает алгоритм **Epsilon-Greedy**.

## **Softmax**

Первый алгоритм, который мы опишем и который учитывает эту структурную информацию, называется алгоритмом **Softmax**. Алгоритм **Softmax** пытается справиться с руками, отличающимся по выигрышу, путем явного включения информации о вознаграждения доступных рук в свой метод выбора руки, которую следует выбрать при исследовании.

Вы можете получить начальное представление о том, как алгоритм **Softmax** справляется с этой проблемой, представив, что **вы выбираете каждую руку пропорционально ее вознаграждению**. 

Предположим, что у вас есть две руки, A и B. Теперь представьте, что, исходя из вашего прошлого опыта, эти две руки имели два разных коэффициента успеха: rA и rB. При таких предположениях самая наивная возможная реализация Softmax-подобного алгоритма заставит вас выбрать руку A с вероятностью $\frac{rA}{rA + rB}$, а руку B - с вероятностью $\frac{rB}{rA + rB}$. 

В коде этот пропорциональный подход будет выглядеть так:

```python

def categorical_draw(probs: list) -> int:
    z = random.random()
    cum_prob = 0.0
    for i in range(len(probs)):
        prob = probs[i]
        cum_prob += prob
        if cum_prob > z:
            return i
    return len(probs) - 1